类的加载过程:
当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接(验证、准备、解析)、初始化3个步骤来对该类进行初始化。

如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。

1.加载
将java对象解析成Class文件,接着读入到内存中进行加载,然后创建Class对象。

2.连接
当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。

2.1 验证
主要是验证当前的Class文件是否符合jre虚拟机要求:其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

2.2 准备
准备为类的静态变量分配内存空间,并设置默认初始值

2.3 解析
将类的二进制数据中的符号引用替换成直接引用。 直接引用:是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。

3.初始化
初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，
它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，
所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。

类的加载机制
全盘负责：当一个类加载器加载某个Class时，该Class所依赖和引用的其它Class也将由该类加载器负责载入，
除非显式的使用另外一个类加载器来载入。

双亲委派：当一个类加载器收到了类加载请求，它会把这个请求委派给父（parent）类加载器去完成，依次递归，
因此所有的加载请求最终都被传送到顶层的启动类加载器中。
只有在父类加载器无法加载该类时子类才尝试从自己类的路径中加载该类。（注意：类加载器中的父子关系并不是类继承上的父子关系，而是类加载器实例之间的关系。）

缓存机制：缓存机制会保证所有加载过的Class都会被缓存，当程序中需要使用某个类时，
类加载器先从缓冲区中搜寻该类，若搜寻不到将读取该类的二进制数据，并转换成Class对象存入缓冲区中。
这就是为什么修改了Class后需重启JVM才能生效的原因。

执行顺序：

1、类内容（静态变量、静态初始化块） => 实例内容（变量、初始化块、构造器）

2、父类的（静态变量、静态初始化块）=> 子类的（静态变量、静态初始化块）=> 父类的（变量、初始化块、构造器）=> 子类的（变量、初始化块、构造器）

https://www.cnblogs.com/Survivalist/p/9015754.html
